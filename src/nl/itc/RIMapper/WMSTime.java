package nl.itc.RIMapper;/** * Class for storing an OGC WMS TIME.<br/> * &copy;2006-2011 International Institute for Geo-information Science and Earth * Observation (ITC) <br/> * Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 2.5 * License. see <a href="http://creativecommons.org/licenses/by-nc-sa/2.5/" * target="_blank"> http://creativecommons.org/licenses/by-nc-sa/2.5/</a> *  * @author Barend K&ouml;bben - <a href="mailto:kobben@itc.nl" target="_blank"> *         kobben@itc.nl </a> * @version 1.0 [September 2011] *///// Major changes:// 1.0 [September 2011]// - first version///** * @author kobben * *//** * @author kobben * */public class WMSTime {  public final static String ISO_TIME_PATTERN = "YYYY-MM-DD HH24:MI:SS";  public final static String JAVA_TIME_PATTERN = "yyyy-MM-dd HH:mm:ss";  public final static String SQL_TO_TIMESTAMP = "to_timestamp(";  public final static String SQL_TO_EPOCH = "EXTRACT (epoch FROM ";    private boolean timeRequested = false;  private String timeRequestISO = ""; //$NON-NLS-1$  private String fromDateTimeISO = ""; //$NON-NLS-1$  private String toDateTimeISO = ""; //$NON-NLS-1$  private long fromEpochSecs = 0; //$NON-NLS-1$  private long toEpochSecs = 0; //$NON-NLS-1$  private String periodicityISO = ""; //$NON-NLS-1$  /**   * constructor:   * Analyses and picks aparts a TIME (ISO8601:1988(E)) parameter.    * Deals with single time instance ( 'datetime' )    * OR contiguous time periods ( 'datetime_begin/datetime_end' )    * Ignores periodicity for now: ('datetime_begin/datetime_end/Period')    *   => last part is ignored and contiguous time period is returned   *    * @throws RIMapperException    */  public WMSTime(String theTimeStr) throws RIMapperException  {    String partsPeriodSplit = "/"; //$NON-NLS-1$    String partsListSplit = ","; //$NON-NLS-1$    String[] parts;    try {      if (theTimeStr == null || theTimeStr.equalsIgnoreCase("null")) {        this.timeRequested = false;      } else {        this.timeRequested = true;        parts = theTimeStr.split(partsListSplit);        if (parts.length > 1) { // its a comma-delimited list          throw new RIMapperException("[WMSTime] 'TIME=" + theTimeStr + "': " + Messages.getString("WMSTime.1")); //$NON-NLS-1$        }        parts = theTimeStr.split(partsPeriodSplit);        if (parts.length == 1) { // there is 1 = datetime          this.fromDateTimeISO = parts[0];          this.toDateTimeISO = parts[0];          this.timeRequestISO = parts[0];        } else if (parts.length == 2 || parts.length == 3) {           // if there are 2 = period (from/to)          this.fromDateTimeISO = parts[0];          this.toDateTimeISO = parts[1];          this.timeRequestISO = parts[0] + partsPeriodSplit + parts[1];          // if there are 3 = periodicity: ignored for now        } else { // something unexpexted          this.timeRequestISO = theTimeStr;          throw new RIMapperException("[WMSTime] 'TIME=" + theTimeStr + "': " + Messages.getString("WMSTime.3")); //$NON-NLS-1$        }      }    } catch (RuntimeException e) {        throw new RIMapperException("[WMSTime] **RuntimeException**: " + e.toString()); //$NON-NLS-1$//    } catch (ParseException e) {//      throw new RIMapperException("[WMSTime] Cannot parse dateTimeISO string: " + e.toString()); //$NON-NLS-1$    }  }  /**   * Static Utility class to create SQL to convert ISO string to timestamp    * @param timeCol an ISO8061 formatted column   * @return an SQL fragment   */  public static String timestamp(String timeCol) {    return SQL_TO_TIMESTAMP + timeCol + ",'" + ISO_TIME_PATTERN  +  "')";   }    /**   * Static Utility class to create SQL to convert ISO strings to seconds since Epoch    * @param timeCol an ISO8061 formatted column   * @return an SQL fragment   */  public static String seconds(String timeCol) {    return SQL_TO_EPOCH + timestamp(timeCol) +  ") ";   }  /**   * @return the timeRequested   */  public boolean isTimeRequested() {    return timeRequested;  }  /**   * @return the timeRequestISO interpreted version of TIME field as used in DB   *         query and forwarded to subsequent calls...   */  public String getTimeRequestISO() {    return timeRequestISO;  }  /**   * @return the fromDateTimeISO   */  public String getFromDateTimeISO() {    return fromDateTimeISO;  }  /**   * @return the toDateTimeISO   */  public String getToDateTimeISO() {    return toDateTimeISO;  }  /**   * @return the periodicityISO   */  public String getPeriodicityISO() {    return periodicityISO;  }  /**   * @return the fromEpochSecs   */  public  long getFromEpochSecs() {    return fromEpochSecs;  }  /**   * @return the toEpochSecs   */  public  long getToEpochSecs() {    return toEpochSecs;  }}